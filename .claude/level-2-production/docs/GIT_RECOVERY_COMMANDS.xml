<?xml version="1.0" encoding="UTF-8"?>
<document type="guide" version="1.0.0">
  <metadata>
    <title>Git Recovery Commands Quick Reference</title>
    <purpose>Emergency git operations for system recovery and data preservation</purpose>
    <audience>Production system operators and developers</audience>
    <last-updated>2025-08-12</last-updated>
  </metadata>

  <introduction>
    <technical>Emergency git operations for system recovery and data preservation</technical>
    <simple>Like having first aid instructions - quick help when things go wrong</simple>
    <connection>This teaches crisis management and recovery procedures in production systems</connection>
  </introduction>

  <emergency-recovery>
    <title>Emergency Recovery Commands</title>

    <immediate-actions>
      <title>Immediate Actions (When in Trouble)</title>

      <status-check>
        <title>Check Current Status</title>
        <commands>
          <command>git status</command>
          <command>git log --oneline -10</command>
          <command>git diff --name-only</command>
        </commands>
      </status-check>

      <information-gathering>
        <title>Safe Information Gathering</title>
        <commands>
          <command>git log --stat -5</command>
          <command>git log --oneline --graph --all -10</command>
          <command>git log --grep="keyword" --oneline</command>
        </commands>
      </information-gathering>
    </immediate-actions>

    <undo-operations>
      <title>Undo Operations (Safe)</title>

      <unstage-files>
        <title>Unstage Files (Keep Changes)</title>
        <commands>
          <command description="Unstage specific file">git restore --staged filename.md</command>
          <command description="Unstage all files">git restore --staged .</command>
          <command description="See what would be unstaged">git diff --cached</command>
        </commands>
      </unstage-files>

      <discard-changes>
        <title>Discard Working Changes ⚠️</title>
        <commands>
          <command description="Discard changes to specific file">git restore filename.md</command>
          <command description="Discard all working changes (CAREFUL!)">git restore .</command>
          <command description="Discard specific directory changes">git restore path/to/directory/</command>
        </commands>
      </discard-changes>

      <undo-commit>
        <title>Undo Last Commit (Keep Changes)</title>
        <commands>
          <command description="Move HEAD back one commit, keep changes staged">git reset --soft HEAD~1</command>
          <command description="Move HEAD back one commit, keep changes unstaged">git reset HEAD~1</command>
          <command description="Check what happened">git status</command>
        </commands>
      </undo-commit>
    </undo-operations>

    <destructive-recovery>
      <title>Emergency Recovery (Destructive)</title>
      <warning>These commands destroy changes - use with extreme caution</warning>

      <reset-commands>
        <title>Reset to Previous Commit ⚠️</title>
        <commands>
          <command description="DESTROYS CHANGES - moves to previous commit">git reset --hard HEAD~1</command>
          <command description="DESTROYS CHANGES - moves to specific commit">git reset --hard COMMIT_HASH</command>
          <command description="DESTROYS CHANGES - moves to last known good state">git reset --hard origin/main</command>
        </commands>
      </reset-commands>

      <specific-point-reset>
        <title>Reset to Specific Point ⚠️</title>
        <commands>
          <command description="Find the commit you want">git log --oneline -20</command>
          <command description="Reset to that commit (DESTROYS later commits)">git reset --hard COMMIT_HASH</command>
          <command description="Force push if needed (BE VERY CAREFUL)">git push --force-with-lease origin main</command>
        </commands>
      </specific-point-reset>
    </destructive-recovery>

    <finding-lost-work>
      <title>Finding Lost Work</title>

      <reflog-recovery>
        <title>Reflog (Recent Actions)</title>
        <commands>
          <command description="Show recent HEAD movements">git reflog</command>
          <command description="Show reflog with timestamps">git reflog --date=iso</command>
          <command description="Recover from reflog entry">git reset --hard HEAD@{5}</command>
        </commands>
      </reflog-recovery>

      <deleted-files>
        <title>Finding Deleted Files</title>
        <commands>
          <command description="Find when file was deleted">git log --oneline --follow -- path/to/file</command>
          <command description="Restore file from before deletion">git restore --source=COMMIT_HASH -- path/to/file</command>
          <command description="Show file content from specific commit">git show COMMIT_HASH:path/to/file</command>
        </commands>
      </deleted-files>

      <cherry-pick>
        <title>Cherry-Pick Lost Commits</title>
        <commands>
          <command description="Apply specific commit to current branch">git cherry-pick COMMIT_HASH</command>
          <command description="Apply multiple commits">git cherry-pick HASH1 HASH2 HASH3</command>
          <command description="Apply range of commits">git cherry-pick HASH1..HASH2</command>
        </commands>
      </cherry-pick>
    </finding-lost-work>

    <recovery-scenarios>
      <title>Specific Recovery Scenarios</title>

      <wrong-files>
        <title>Committed Wrong Files</title>
        <solution>
          <step>git add correct_file.md</step>
          <step>git commit --amend -m "Fixed commit message"</step>
          <alternative>
            <step>git reset --soft HEAD~1</step>
            <step>git restore --staged wrong_file.md</step>
            <step>git commit -m "Corrected commit"</step>
          </alternative>
        </solution>
      </wrong-files>

      <sensitive-data>
        <title>Committed Secrets/Sensitive Data</title>
        <immediate-fix>
          <step>git reset --soft HEAD~1</step>
          <step>git restore --staged .env</step>
          <step>echo ".env" &gt;&gt; .gitignore</step>
          <step>git add .gitignore</step>
          <step>git commit -m "Remove sensitive data and update gitignore"</step>
        </immediate-fix>
        <nuclear-option>
          <step>git filter-branch --tree-filter 'rm -f .env' HEAD</step>
          <step>git push --force-with-lease origin main</step>
        </nuclear-option>
      </sensitive-data>

      <corrupted-directory>
        <title>Corrupted Working Directory</title>
        <commands>
          <command description="Clean untracked files">git clean -fd</command>
          <command description="Reset everything to last commit">git reset --hard HEAD</command>
          <command description="Verify clean state">git status</command>
        </commands>
      </corrupted-directory>

      <merge-conflicts>
        <title>Merge Conflicts</title>
        <commands>
          <command description="Abort merge and return to pre-merge state">git merge --abort</command>
          <command description="Reset merge conflicts and start over">git reset --hard HEAD</command>
          <command description="Show conflicts">git diff --name-only --diff-filter=U</command>
        </commands>
      </merge-conflicts>
    </recovery-scenarios>

    <session-recovery>
      <title>Session Recovery Specific</title>

      <session-state>
        <title>Session State Recovery</title>
        <commands>
          <command description="Find session-related commits">git log --grep="session" --oneline -10</command>
          <command description="Restore session files">git restore --source=HEAD~1 -- .claude/level-2-production/sessions/</command>
          <command description="Check session integrity">.claude/level-2-production/tests/test-session-recovery.sh</command>
        </commands>
      </session-state>

      <agent-pipeline>
        <title>Agent Pipeline Recovery</title>
        <commands>
          <command description="Restore all agents to last working state">git restore .claude/level-2-production/agents/</command>
          <command description="Verify pipeline integrity">.claude/level-2-production/tests/test-circular-dependencies.sh</command>
          <command description="Check for circular dependencies">git log --grep="circular" --oneline</command>
        </commands>
      </agent-pipeline>

      <configuration-recovery>
        <title>Configuration Recovery</title>
        <commands>
          <command description="Restore config files">git restore .claude/level-2-production/config/</command>
          <command description="Validate configuration">python3 -c "import yaml; yaml.safe_load(open('.claude/level-2-production/config/environment.yaml'))"</command>
          <command description="Test system readiness">.claude/hooks/pre-production.sh</command>
        </commands>
      </configuration-recovery>
    </session-recovery>

    <branch-management>
      <title>Branch Management Recovery</title>

      <create-recovery-branch>
        <title>Create Recovery Branch</title>
        <commands>
          <command description="Create branch from current state">git checkout -b recovery-$(date +%Y%m%d-%H%M)</command>
          <command description="Create branch from specific commit">git checkout -b recovery-point COMMIT_HASH</command>
          <command description="Switch back to main">git checkout main</command>
        </commands>
      </create-recovery-branch>

      <compare-merge>
        <title>Compare and Merge Recovery</title>
        <commands>
          <command description="Compare branches">git diff main recovery-branch</command>
          <command description="Merge specific files from recovery">git checkout recovery-branch -- specific/file.md</command>
          <command description="Merge entire recovery branch">git merge recovery-branch</command>
        </commands>
      </compare-merge>
    </branch-management>

    <production-recovery>
      <title>Production System Recovery</title>

      <hooks-recovery>
        <title>Hooks Recovery</title>
        <commands>
          <command description="Restore hooks to working state">git restore .claude/hooks/</command>
          <command description="Make hooks executable">chmod +x .claude/hooks/*.sh</command>
          <command description="Test hooks">.claude/hooks/pre-production.sh</command>
        </commands>
      </hooks-recovery>

      <test-suite-recovery>
        <title>Test Suite Recovery</title>
        <commands>
          <command description="Restore test suite">git restore .claude/level-2-production/tests/</command>
          <command description="Make tests executable">chmod +x .claude/level-2-production/tests/*.sh</command>
          <command description="Run comprehensive validation">.claude/level-2-production/tests/test-all-scripts.sh</command>
        </commands>
      </test-suite-recovery>

      <tools-recovery>
        <title>Tools Recovery</title>
        <commands>
          <command description="Restore production tools">git restore .claude/level-2-production/tools/</command>
          <command description="Make tools executable">chmod +x .claude/level-2-production/tools/*.sh</command>
          <command description="Test critical tools">.claude/level-2-production/tools/brand-detector.sh test-file.md</command>
        </commands>
      </tools-recovery>
    </production-recovery>

    <quick-workflows>
      <title>Quick Recovery Workflows</title>

      <standard-recovery>
        <title>Standard Recovery Process</title>
        <steps>
          <step description="Assess situation">
            <command>git status</command>
            <command>git log --oneline -5</command>
          </step>
          <step description="Create safety branch">
            <command>git checkout -b emergency-backup-$(date +%Y%m%d-%H%M)</command>
          </step>
          <step description="Return to main and fix">
            <command>git checkout main</command>
            <command>git reset --hard origin/main</command>
          </step>
          <step description="Verify system">
            <command>.claude/level-2-production/tests/test-all-scripts.sh</command>
          </step>
          <step description="Clean up if successful">
            <command>git branch -D emergency-backup-*</command>
          </step>
        </steps>
      </standard-recovery>

      <nuclear-recovery>
        <title>Nuclear Recovery (Last Resort)</title>
        <steps>
          <step description="Backup current work">
            <command>git stash push -m "Emergency backup $(date)"</command>
          </step>
          <step description="Reset to known good state">
            <command>git reset --hard origin/main</command>
          </step>
          <step description="Verify everything works">
            <command>.claude/level-2-production/tests/test-all-scripts.sh</command>
            <command>.claude/hooks/pre-production.sh</command>
          </step>
          <step description="Review stashed work later">
            <command>git stash list</command>
            <command>git stash show stash@{0}</command>
          </step>
        </steps>
      </nuclear-recovery>
    </quick-workflows>

    <verification>
      <title>Help and Verification</title>

      <verify-recovery>
        <title>Verify Recovery Success</title>
        <commands>
          <command description="System health check">.claude/level-2-production/tests/test-all-scripts.sh</command>
          <command description="Pipeline integrity">.claude/level-2-production/tests/test-circular-dependencies.sh</command>
          <command description="Session recovery">.claude/level-2-production/tests/test-session-recovery.sh</command>
          <command description="MCP connectivity">.claude/level-2-production/tests/test-mcp-connectivity.sh</command>
          <command description="Pre-production readiness">.claude/hooks/pre-production.sh</command>
        </commands>
      </verify-recovery>

      <get-help>
        <title>Get Help</title>
        <commands>
          <command description="Show git help for command">git help reset</command>
          <command description="Show git help for reflog">git help reflog</command>
          <command description="Show git help for cherry-pick">git help cherry-pick</command>
          <command description="Show recent actions">git reflog --all --graph --decorate --oneline</command>
          <command description="Get status of everything">git status --ignored --porcelain</command>
        </commands>
      </get-help>
    </verification>

    <dangerous-commands>
      <title>NEVER Commands (Dangerous)</title>
      <warning>These commands should NEVER be used</warning>
      <forbidden-commands>
        <command danger="Deletes entire git history">rm -rf .git</command>
        <command danger="Overwrites remote without checks">git push --force origin main</command>
        <command danger="Loses multiple commits without backup">git reset --hard HEAD~10</command>
        <command danger="Deletes remote branches">git push origin --delete branch-name</command>
        <command danger="Rewrites shared history">git rebase -i HEAD~10</command>
      </forbidden-commands>
    </dangerous-commands>
  </emergency-recovery>

  <footer>
    <emergency-contact>Run `git reflog` and `git status` - these commands are always safe and show what happened.</emergency-contact>
    <version>Production Ready</version>
    <updated>2025-08-12</updated>
    <purpose>Crisis Recovery</purpose>
  </footer>
</document>
