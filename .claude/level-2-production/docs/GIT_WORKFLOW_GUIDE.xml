<?xml version="1.0" encoding="UTF-8"?>
<document type="guide" version="1.0.0">
  <metadata>
    <title>Git Workflow Guide - Production System</title>
    <purpose>Atomic commit strategy with semantic versioning and automated quality gates</purpose>
    <audience>Developers and production system operators</audience>
    <last-updated>2025-08-12</last-updated>
  </metadata>

  <introduction>
    <technical>Atomic commit strategy with semantic versioning and automated quality gates</technical>
    <simple>Like saving your work frequently with good descriptions of what you changed</simple>
    <connection>This teaches professional version control practices and collaborative development</connection>
  </introduction>

  <atomic-commit-philosophy>
    <title>Atomic Commit Philosophy</title>

    <core-principle>
      <rule>One logical change = One commit</rule>
      <technical>Atomic commits enable clean rollbacks, better debugging, and clear change tracking</technical>
      <simple>Like organizing photos in albums - each commit contains related changes that make sense together</simple>
      <connection>This teaches change management and systematic development practices</connection>
    </core-principle>

    <good-examples>
      <title>Good Atomic Commits</title>
      <examples>
        <example type="feature">feat(agents): add research coordinator with API integration</example>
        <example type="bugfix">fix(quality): correct brand voice calculation threshold</example>
        <example type="config">config(hooks): update pre-commit timeout from 30s to 60s</example>
        <example type="docs">docs(quick-start): add MCP troubleshooting section</example>
      </examples>
    </good-examples>

    <poor-examples>
      <title>Poor Atomic Commits</title>
      <examples>
        <example type="multiple-unrelated">fix bugs and add features and update docs</example>
        <example type="too-granular">fix typo (followed by) fix another typo in same file</example>
        <example type="too-vague">updates</example>
        <example type="too-vague">changes</example>
      </examples>
    </poor-examples>
  </atomic-commit-philosophy>

  <semantic-commit-format>
    <title>Semantic Commit Format</title>

    <required-format>
      <structure>
        &lt;type&gt;(&lt;scope&gt;): &lt;description&gt;

        &lt;body&gt;

        ü§ñ Generated with [Claude Code](https://claude.ai/code)

        Co-Authored-By: Claude &lt;noreply@anthropic.com&gt;
      </structure>
    </required-format>

    <commit-types>
      <type name="feat">New feature</type>
      <type name="fix">Bug fix</type>
      <type name="docs">Documentation changes</type>
      <type name="style">Formatting, missing semicolons, etc.</type>
      <type name="refactor">Code changes that neither fix bugs nor add features</type>
      <type name="test">Adding or updating tests</type>
      <type name="chore">Updating build tasks, package manager configs, etc.</type>
      <type name="config">Configuration file changes</type>
      <type name="hooks">Git hook modifications</type>
    </commit-types>

    <scope-examples>
      <scope name="agents">Pipeline agent modifications</scope>
      <scope name="tools">Utility script changes</scope>
      <scope name="config">Configuration updates</scope>
      <scope name="testing">Test suite changes</scope>
      <scope name="hooks">Automation hook changes</scope>
      <scope name="docs">Documentation updates</scope>
    </scope-examples>

    <educational-value>
      <technical>Semantic commits enable automated changelog generation and release management</technical>
      <simple>Like using categories in your filing system - makes finding specific changes easy</simple>
      <connection>This teaches structured communication and change categorization</connection>
    </educational-value>
  </semantic-commit-format>

  <production-workflow>
    <title>Production Workflow</title>

    <daily-cycle>
      <title>Daily Development Cycle</title>

      <start-work>
        <title>1. Start Work Session</title>
        <commands>
          <command description="Check current state">git status</command>
          <command description="Pull latest changes (if collaborative)">git pull origin main</command>
          <command description="Verify clean working directory">git diff --exit-code || echo "Uncommitted changes detected"</command>
        </commands>
      </start-work>

      <make-changes>
        <title>2. Make Changes</title>
        <steps>
          <step>Edit files for single logical change</step>
          <step>Test changes work correctly: .claude/level-2-production/tests/test-all-scripts.sh</step>
          <step>Validate specific components: .claude/level-2-production/tools/brand-detector.sh test_file.md</step>
        </steps>
      </make-changes>

      <commit-changes>
        <title>3. Commit Changes</title>
        <process>
          <step description="Add specific files (not git add .)">git add .claude/level-2-production/agents/01_research_coordinator.md</step>
          <step description="Write clear commit message">
            git commit -m "feat(agents): enhance research coordinator with source validation

            - Add minimum 3 sources requirement
            - Implement credibility scoring
            - Add timeout handling for API requests
            - Validate source diversity (academic, industry, news)

            Technical: Multi-source validation improves research quality
            Simple: Like checking multiple opinions before making decisions
            Connection: This teaches research methodology and quality assurance

            ü§ñ Generated with [Claude Code](https://claude.ai/code)

            Co-Authored-By: Claude &lt;noreply@anthropic.com&gt;"
          </step>
        </process>
      </commit-changes>

      <session-completion>
        <title>4. Session Completion</title>
        <commands>
          <command description="Session completion hook auto-commits remaining changes">.claude/hooks/session-complete.sh</command>
          <note>Creates session summary and final commit</note>
        </commands>
      </session-completion>
    </daily-cycle>

    <educational-value>
      <technical>Structured workflow ensures consistent quality and traceability across development sessions</technical>
      <simple>Like following a recipe - each step builds on the previous one for predictable results</simple>
      <connection>This teaches systematic development methodology and quality control</connection>
    </educational-value>
  </production-workflow>

  <branch-strategy>
    <title>Branch Strategy</title>

    <current-approach>
      <title>Main Branch Only (Current)</title>
      <characteristics>
        <item>All development on main branch</item>
        <item>Atomic commits ensure stability</item>
        <item>Pre-commit hooks prevent broken states</item>
        <item>Session completion creates natural checkpoints</item>
      </characteristics>
    </current-approach>

    <future-branching>
      <title>Future Branching (When Collaborative)</title>
      <workflow>
        <step description="Feature branch for new agent">git checkout -b feature/audio-synthesizer-agent</step>
        <step description="Work on feature with atomic commits">git commit -m "feat(agents): implement ElevenLabs integration"</step>
        <step description="Merge when complete">
          git checkout main
          git merge feature/audio-synthesizer-agent
          git branch -d feature/audio-synthesizer-agent
        </step>
      </workflow>
    </future-branching>
  </branch-strategy>

  <quality-gates>
    <title>Quality Gates</title>

    <pre-commit-validation>
      <title>Pre-Commit Validation</title>
      <description>Automatically runs on every commit</description>
      <checks>
        <check>Backup file detection</check>
        <check>TODO marker scanning</check>
        <check>Integration test execution</check>
        <check>Commit message format validation</check>
        <check>File size checks</check>
      </checks>
      <script>.claude/hooks/pre-commit-quality.sh</script>
    </pre-commit-validation>

    <manual-gates>
      <title>Manual Quality Gates</title>
      <commands>
        <command when="Before major changes">.claude/hooks/pre-production.sh</command>
        <command when="After significant work">.claude/level-2-production/tests/test-all-scripts.sh</command>
        <command when="Brand voice validation">.claude/level-2-production/tools/brand-detector.sh script.md</command>
      </commands>
    </manual-gates>
  </quality-gates>

  <recovery-commands>
    <title>Recovery Commands</title>

    <safe-operations>
      <command description="Undo Last Commit (Keep Changes)">git reset --soft HEAD~1</command>
      <command description="Fix Commit Message">git commit --amend -m "corrected commit message"</command>
      <command description="Unstage specific file">git restore --staged filename</command>
      <command description="Unstage all files">git restore --staged .</command>
    </safe-operations>

    <destructive-operations>
      <warning>These operations destroy changes - use with caution</warning>
      <command description="Undo Last Commit (Discard Changes)">git reset --hard HEAD~1</command>
      <command description="Discard specific file changes">git restore filename</command>
      <command description="Discard all changes">git restore .</command>
    </destructive-operations>

    <advanced-recovery>
      <command description="Find when file was deleted">git log --oneline -- path/to/file</command>
      <command description="Restore from commit before deletion">git restore --source=COMMIT_HASH -- path/to/file</command>
      <command description="Show reflog (recent HEAD changes)">git reflog</command>
      <command description="Recover from reflog entry">git reset --hard HEAD@{2}</command>
      <command description="Create branch from lost commit">git checkout -b recovery COMMIT_HASH</command>
    </advanced-recovery>

    <educational-value>
      <technical>Recovery commands enable safe experimentation and error correction without data loss</technical>
      <simple>Like having multiple save files in a game - you can always go back to a working state</simple>
      <connection>This teaches risk management and system recovery procedures</connection>
    </educational-value>
  </recovery-commands>

  <session-management>
    <title>Session State Management</title>

    <lifecycle>
      <title>Session Lifecycle</title>
      <steps>
        <step description="Session Start (automatic with hooks)">session_id="session_$(date +%Y%m%d_%H%M)"</step>
        <step description="Work with atomic commits">
          git add specific_files
          git commit -m "type(scope): description"
        </step>
        <step description="Session completion (automatic)">.claude/hooks/session-complete.sh</step>
      </steps>
    </lifecycle>

    <recovery>
      <title>Session Recovery</title>
      <commands>
        <command description="Find incomplete sessions">find .claude/level-2-production/sessions/active -name "*.json"</command>
        <command description="Use recovery helper">.claude/level-2-production/tools/recovery-helper.sh session_id</command>
        <command description="Check git state for session">git log --oneline --since="1 hour ago"</command>
      </commands>
    </recovery>
  </session-management>

  <cost-tracking>
    <title>Cost Tracking Integration</title>

    <git-hooks-integration>
      <title>Git Hooks + Cost Monitoring</title>
      <pre-commit-validation>
        if costs &gt; threshold:
          echo "Cost threshold exceeded, commit blocked"
          exit 1
      </pre-commit-validation>
      <post-commit-tracking>
        git log --oneline | head -5
        .claude/level-2-production/tools/analyze_sessions.py --recent-costs
      </post-commit-tracking>
    </git-hooks-integration>

    <cost-related-commits>
      <title>Cost-Related Commits</title>
      <examples>
        <example type="optimization">perf(agents): reduce token usage by 30% with prompt optimization</example>
        <example type="tracking">feat(tools): add real-time cost monitoring dashboard</example>
      </examples>
    </cost-related-commits>
  </cost-tracking>

  <collaborative-features>
    <title>Collaborative Features (Future)</title>

    <pull-request-workflow>
      <title>Pull Request Workflow</title>
      <process>
        <step description="Create feature branch">git checkout -b feature/new-quality-gate</step>
        <step description="Make changes with atomic commits">git commit -m "feat(quality): add technical accuracy validation"</step>
        <step description="Push and create PR">git push origin feature/new-quality-gate</step>
      </process>
    </pull-request-workflow>

    <code-review-integration>
      <title>Code Review Integration</title>
      <requirements>
        <item>All commits require semantic format</item>
        <item>Pre-commit hooks ensure quality</item>
        <item>Automated testing validates changes</item>
        <item>Brand voice consistency checks</item>
      </requirements>

      <educational-value>
        <technical>Collaborative features enable team development while maintaining quality and consistency</technical>
        <simple>Like having multiple people work on a project with clear rules and automatic checking</simple>
        <connection>This teaches team collaboration and quality assurance in group settings</connection>
      </educational-value>
    </code-review-integration>
  </collaborative-features>

  <best-practices>
    <title>Best Practices Summary</title>

    <dos>
      <title>Do's ‚úÖ</title>
      <practice>One logical change per commit</practice>
      <practice>Use semantic commit format</practice>
      <practice>Test before committing</practice>
      <practice>Write descriptive commit messages</practice>
      <practice>Include dual explanations in significant commits</practice>
      <practice>Use atomic operations for related changes</practice>
      <practice>Validate quality gates before pushing</practice>
    </dos>

    <donts>
      <title>Don'ts ‚ùå</title>
      <practice>Don't commit broken code</practice>
      <practice>Don't use `git add .` blindly</practice>
      <practice>Don't commit secrets or API keys</practice>
      <practice>Don't skip pre-commit hooks</practice>
      <practice>Don't create backup files (use git instead)</practice>
      <practice>Don't commit temporary or generated files</practice>
      <practice>Don't use generic commit messages</practice>
    </donts>

    <emergency-procedures>
      <title>Emergency Procedures</title>
      <procedure description="System completely broken">git reset --hard origin/main</procedure>
      <procedure description="Lost important changes">
        git reflog  # Find lost commits
        git cherry-pick COMMIT_HASH
      </procedure>
      <procedure description="Accidental secret commit">git filter-branch --tree-filter 'rm -f .env' HEAD</procedure>
    </emergency-procedures>
  </best-practices>

  <footer>
    <version>Production Ready</version>
    <atomic-commits>Enforced</atomic-commits>
    <quality-gates>Automated</quality-gates>
  </footer>
</document>
