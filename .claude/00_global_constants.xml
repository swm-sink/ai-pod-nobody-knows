<?xml version="1.0" encoding="UTF-8"?>
<document type="constants" domain="shared" version="3.0" xmlns="https://ai-podcasts-nobody-knows.com/claude-docs">
    <metadata>
        <title>Global Constants and Standards</title>
        <claude-optimization>true</claude-optimization>
    </metadata>

    <content>
        <section type="constants" id="architecture-constants">
            <technical-explanation>
                4-Level Architecture constants define the hierarchical separation of concerns with strict dependency management and controlled progression gates. Each level serves a specific purpose in the development and production workflow.
            </technical-explanation>
            <simple-explanation>
                These are the basic building blocks that organize the entire project into four levels, like floors in a building where each floor has a specific purpose and you can only move up when you're ready.
            </simple-explanation>

            <constants>
                <constant>
                    <name>LEVEL_1_DEV</name>
                    <value>.claude/level-1-dev/</value>
                    <description>Development Platform - Tools that build the production system</description>
                </constant>
                <constant>
                    <name>LEVEL_2_PRODUCTION</name>
                    <value>.claude/level-2-production/</value>
                    <description>Podcast Production - Native Claude Code podcast production</description>
                </constant>
                <constant>
                    <name>LEVEL_3_PLATFORM</name>
                    <value>.claude/level-3-platform-dev/</value>
                    <description>Platform Planning - Design future coded platform</description>
                </constant>
                <constant>
                    <name>LEVEL_4_CODED</name>
                    <value>.claude/level-4-coded/</value>
                    <description>Future Implementation (REQUIRES EXPLICIT APPROVAL)</description>
                </constant>
            </constants>
        </section>

        <section type="constants" id="file-naming-conventions">
            <technical-explanation>
                Standardized file naming conventions ensure consistent organization and prevent naming conflicts across the system. These patterns enable programmatic file discovery and maintain clear separation between development and production assets.
            </technical-explanation>
            <simple-explanation>
                Consistent naming rules so everyone knows where to find things and what type of file they're looking at just from the name.
            </simple-explanation>

            <constants>
                <constant>
                    <name>DEV_TOOLS_PATTERN</name>
                    <value>*-dev.md</value>
                    <description>Development tools and utilities</description>
                </constant>
                <constant>
                    <name>PRODUCTION_TOOLS_PATTERN</name>
                    <value>*-production.md</value>
                    <description>Production tools and workflows</description>
                </constant>
                <constant>
                    <name>SESSION_FILENAME_PATTERN</name>
                    <value>[type]_YYYYMMDD_HHMM.json</value>
                    <description>Session tracking files with timestamp</description>
                </constant>
                <constant>
                    <name>EPISODE_FILENAME_PATTERN</name>
                    <value>ep_XXX_*</value>
                    <description>Episode files where XXX is episode number</description>
                </constant>
            </constants>
        </section>

        <section type="constants" id="quality-standards">
            <technical-explanation>
                Quality assurance thresholds and validation criteria for automated systems. These metrics ensure consistent output quality and enable automated decision-making in the production pipeline.
            </technical-explanation>
            <simple-explanation>
                The standards that determine if something is "good enough" to proceed - like grade thresholds in school.
            </simple-explanation>

            <constants>
                <constant>
                    <name>BRAND_VOICE_TARGET</name>
                    <value>0.90</value>
                    <description>Minimum brand consistency score (0-1 scale)</description>
                </constant>
                <constant>
                    <name>QUALITY_SCORE_TARGET</name>
                    <value>0.85</value>
                    <description>Minimum overall quality score for acceptance</description>
                </constant>
                <constant>
                    <name>EPISODE_DURATION_MINUTES</name>
                    <value>27</value>
                    <description>Target episode duration in minutes</description>
                </constant>
                <constant>
                    <name>EPISODE_WORD_COUNT_MIN</name>
                    <value>3900</value>
                    <description>Minimum word count for episode script</description>
                </constant>
                <constant>
                    <name>EPISODE_WORD_COUNT_MAX</name>
                    <value>4100</value>
                    <description>Maximum word count for episode script</description>
                </constant>
                <constant>
                    <name>COST_LIMIT_PER_EPISODE</name>
                    <value>9.00</value>
                    <description>Maximum cost per episode in USD</description>
                </constant>
                <constant>
                    <name>READABILITY_SCORE_MIN</name>
                    <value>60</value>
                    <description>Minimum Flesch-Kincaid readability score</description>
                </constant>
                <constant>
                    <name>READABILITY_SCORE_MAX</name>
                    <value>70</value>
                    <description>Maximum Flesch-Kincaid readability score</description>
                </constant>
            </constants>

            <validation>
                <validation-command>python -c "assert 0.85 &lt;= quality_score &lt;= 1.0, 'Quality score out of range'"</validation-command>
                <validation-command>python -c "assert 3900 &lt;= word_count &lt;= 4100, 'Word count out of range'"</validation-command>
                <success-criteria>All quality metrics within acceptable ranges</success-criteria>
            </validation>
        </section>

        <section type="constants" id="production-pipeline">
            <technical-explanation>
                Production pipeline stages define the sequential workflow for episode creation with clear stage boundaries and validation checkpoints. Each stage has specific inputs, outputs, and success criteria.
            </technical-explanation>
            <simple-explanation>
                The step-by-step process for making each episode, like an assembly line where each station does one job.
            </simple-explanation>

            <constants>
                <constant>
                    <name>STAGE_RESEARCH</name>
                    <value>research</value>
                    <description>Gather and validate information about the topic</description>
                </constant>
                <constant>
                    <name>STAGE_SCRIPT_WRITING</name>
                    <value>script_writing</value>
                    <description>Create narrative structure and episode script</description>
                </constant>
                <constant>
                    <name>STAGE_AUDIO_SYNTHESIS</name>
                    <value>audio_synthesis</value>
                    <description>Generate speech from completed script</description>
                </constant>
                <constant>
                    <name>STAGE_QUALITY_EVALUATION</name>
                    <value>quality_evaluation</value>
                    <description>Validate all outputs against quality standards</description>
                </constant>
            </constants>
        </section>

        <section type="constants" id="mcp-server-limits">
            <technical-explanation>
                MCP (Model Context Protocol) server cost limits and usage constraints to prevent budget overruns and ensure sustainable operation. These limits enable cost-controlled API usage across different service providers.
            </technical-explanation>
            <simple-explanation>
                Spending limits for different AI services to keep costs under control - like having a budget for different types of tools.
            </simple-explanation>

            <constants>
                <constant>
                    <name>PERPLEXITY_LIMIT</name>
                    <value>3.00</value>
                    <description>Maximum spend per episode on Perplexity research (USD)</description>
                </constant>
                <constant>
                    <name>ELEVENLABS_LIMIT</name>
                    <value>2.00</value>
                    <description>Maximum spend per episode on ElevenLabs audio synthesis (USD)</description>
                </constant>
                <constant>
                    <name>WEB_SEARCH_LIMIT</name>
                    <value>free-tier</value>
                    <description>Use free tier only initially for web search</description>
                </constant>
            </constants>
        </section>

        <section type="constants" id="error-recovery">
            <technical-explanation>
                Error recovery constants define resilience patterns for handling failures in distributed AI systems. These values balance reliability against performance, implementing exponential backoff and circuit breaker patterns.
            </technical-explanation>
            <simple-explanation>
                Rules for what to do when things go wrong - like how many times to try again and how long to wait between attempts.
            </simple-explanation>

            <constants>
                <constant>
                    <name>MAX_RETRIES</name>
                    <value>3</value>
                    <description>Maximum number of retry attempts before failure</description>
                </constant>
                <constant>
                    <name>RETRY_BACKOFF_INITIAL</name>
                    <value>30</value>
                    <description>Initial retry delay in seconds</description>
                </constant>
                <constant>
                    <name>RETRY_BACKOFF_SECOND</name>
                    <value>60</value>
                    <description>Second retry delay in seconds</description>
                </constant>
                <constant>
                    <name>RETRY_BACKOFF_FINAL</name>
                    <value>120</value>
                    <description>Final retry delay in seconds</description>
                </constant>
                <constant>
                    <name>SAVE_PROGRESS_TRIGGER</name>
                    <value>stage_completion</value>
                    <description>When to save progress checkpoints</description>
                </constant>
                <constant>
                    <name>SESSION_TIMEOUT</name>
                    <value>60</value>
                    <description>Maximum session duration in minutes before timeout</description>
                </constant>
            </constants>

            <validation>
                <validation-command>python -c "assert 1 &lt;= max_retries &lt;= 5, 'Retry count should be reasonable'"</validation-command>
                <validation-command>python -c "assert 30 &lt;= timeout_minutes &lt;= 120, 'Session timeout should be reasonable'"</validation-command>
                <success-criteria>All error recovery parameters within reasonable operational bounds</success-criteria>
            </validation>
        </section>

        <section type="constants" id="thinking-modes">
            <technical-explanation>
                Claude Code thinking mode specifications for different complexity levels of analysis. These modes optimize computational resources while ensuring appropriate depth of reasoning for different types of problems.
            </technical-explanation>
            <simple-explanation>
                Different levels of "thinking power" to use depending on how complex the problem is - like using a calculator for simple math but a computer for complex calculations.
            </simple-explanation>

            <constants>
                <constant>
                    <name>THINKING_BASIC</name>
                    <value>think</value>
                    <description>Simple analysis and straightforward reasoning</description>
                </constant>
                <constant>
                    <name>THINKING_ENHANCED</name>
                    <value>think hard</value>
                    <description>Complex reasoning and multi-step analysis</description>
                </constant>
                <constant>
                    <name>THINKING_DEEP</name>
                    <value>think harder</value>
                    <description>Multi-perspective analysis and deep consideration</description>
                </constant>
                <constant>
                    <name>THINKING_MAXIMUM</name>
                    <value>ultrathink</value>
                    <description>Comprehensive evaluation for most complex problems</description>
                </constant>
            </constants>
        </section>
    </content>

    <cross-references>
        <reference file="../operations/troubleshooting-guide.xml" section="validation" type="related">
            Troubleshooting guide that uses these constants for validation
        </reference>
        <reference file="../ai-orchestration/cost-optimization-strategies.xml" section="cost-limits" type="related">
            Cost optimization strategies referencing these budget limits
        </reference>
    </cross-references>
</document>
