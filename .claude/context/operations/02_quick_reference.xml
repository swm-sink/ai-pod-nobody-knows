<?xml version="1.0" encoding="UTF-8"?>
<document type="reference" domain="operations" version="3.0" xmlns="https://ai-podcasts-nobody-knows.com/claude-docs">
    <metadata>
        <title>Quick Reference Guide - Essential Commands and Patterns</title>
        <claude-optimization>true</claude-optimization>
        <estimated-time>5-10 minutes for lookup</estimated-time>
    </metadata>

    <content>
        <section type="reference" id="overview">
            <technical-explanation>
                This reference provides immediate access to essential commands, patterns, and workflows for AI podcast production using Claude Code orchestration. It includes traditional development commands alongside Claude Code-specific features like thinking modes, subagents, MCP server integration, and automated workflows. The guide emphasizes practical copy-paste solutions and emergency procedures for rapid problem resolution.
            </technical-explanation>
            <simple-explanation>
                Think of this as your quick-lookup cheat sheet - like having all the most important phone numbers written on a card in your wallet. When you need to do something common or fix a problem quickly, you can find the exact command or pattern here without digging through long documentation.
            </simple-explanation>
        </section>

        <section type="reference" id="essential-commands">
            <instructions>
                <step validation-command="python --version && which python">
                    **Project Setup**: Create virtual environment, install dependencies, configure API keys
                </step>
                <step validation-command="curl http://localhost:8000/health">
                    **Daily Operations**: Start server, run tests, check code quality, view logs
                </step>
                <step validation-command="/mcp || claude mcp list">
                    **Claude Code Integration**: Memory management, thinking modes, MCP servers, file operations
                </step>
                <step validation-command="ps aux | grep uvicorn">
                    **Emergency Recovery**: Context overflow, performance issues, cost spikes, quality degradation
                </step>
            </instructions>

            <examples>
                <example type="basic">
                    <scenario>Start daily development workflow</scenario>
                    <implementation>
                        ```bash
                        source venv/bin/activate
                        /init  # Claude Code memory initialization
                        uvicorn core.orchestration.server:app --reload
                        curl localhost:8000/health && echo "Server OK"
                        ```
                    </implementation>
                    <explanation>This sequence activates your Python environment, initializes Claude Code's project memory system, starts the FastAPI server with auto-reload, and verifies everything is working correctly.</explanation>
                </example>
                <example type="advanced">
                    <scenario>Debug complex multi-agent coordination issue</scenario>
                    <implementation>
                        ```bash
                        # Progressive analysis with Claude Code
                        ultrathink the agent coordination patterns and failure points
                        /subagent create-diagnostic-team --components="research,script,quality,audio"
                        /mcp__health__comprehensive-check --include-latency
                        /hooks validate-all --safe-mode
                        ```
                    </implementation>
                    <explanation>Uses Claude Code's advanced debugging features: deep thinking mode for analysis, specialized subagents for component testing, MCP health checks for external services, and hook validation for automation systems.</explanation>
                </example>
            </examples>
        </section>

        <section type="troubleshooting" id="emergency-procedures">
            <examples>
                <example type="anti-pattern">
                    <scenario>Context window overflow during long debugging session</scenario>
                    <implementation>Continuing to add information without managing context size</implementation>
                    <explanation>Solution: Use `/compact` to summarize conversation, `/clear` to reset (save important info to memory first), or add key information to permanent memory with `# Remember: [key insight]` before clearing.</explanation>
                </example>
            </examples>

            <validation>
                <validation-command>tail -100 logs/*.log | grep -i error | tail -10</validation-command>
                <success-criteria>No critical errors in recent logs, all services responding</success-criteria>
            </validation>
        </section>

        <section type="advanced" id="automation-patterns">
            <technical-explanation>
                Advanced automation patterns leverage Claude Code's hook system for automated quality checks, cost monitoring, and error recovery. Combined with MCP server integration and subagent coordination, these patterns enable self-healing systems that can detect problems, analyze causes, and implement fixes with minimal human intervention.
            </technical-explanation>
            <simple-explanation>
                Think of automation patterns as setting up smart assistants that watch your system 24/7. They can automatically catch problems before they get big, fix common issues on their own, and alert you only when they really need human help - like having a really good IT department built into your software.
            </simple-explanation>

            <examples>
                <example type="advanced">
                    <scenario>Self-healing quality assurance system</scenario>
                    <implementation>
                        ```python
                        # .claude/hooks/pre-tool-use.py
                        def pre_synthesis_quality_check(context):
                            if context.operation == "audio_synthesis":
                                script_quality = evaluate_script_quality(context.script)
                                if script_quality < 0.8:
                                    # Auto-regenerate with improved prompts
                                    context.script = improve_script(context.script)
                            return context
                        ```
                    </implementation>
                    <explanation>Automated hook that checks script quality before expensive audio synthesis, automatically improving low-quality scripts to prevent wasted costs and poor episodes.</explanation>
                </example>
            </examples>
        </section>
    </content>

    <cross-references>
        <reference file="01_troubleshooting_guide.xml" section="claude-code-debugging" type="related">
            Detailed troubleshooting procedures for complex issues
        </reference>
        <reference file="03_production_checklist.xml" section="workflow" type="related">
            Step-by-step production workflow procedures
        </reference>
        <reference file="../claude-code/16_memory_management_system.xml" section="memory" type="prerequisite">
            Claude Code memory system details and best practices
        </reference>
        <reference file="00_operations_constants.md" section="commands" type="reference">
            Complete command definitions and configurations
        </reference>
    </cross-references>
</document>
